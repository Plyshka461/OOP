class Vector:#Объявление класса
    def __init__(self,*args): # конструктор получает произвольное количество аргументов
        self.values = []#Создание пустого списка
        for arg in args:#Цикл для перебора всех аргументов
            if isinstance(arg,int):#Проверка, является ли текущий аргумент целым числом
                self.values.append(arg)# Если текущий аргумент является целым числом, он добавляется в список
            self.values.sort()# Сортировка значений вектора
    def __str__(self):#возвращает строковое представление объекта Vector
        if len(self.values) == 0:#Проверка, пуст ли вектор
            return 'пусть вектор'#Если вектор пуст, возвращается строка "пустой вектор"
        return f'вектор{tuple(self.values)}'# Если вектор не пуст, возвращается строка, представляющая значения вектора в виде кортежа
    def __add__(self, other):#Это определение метода сложения для класса
        new_v=[]#Создается пустой список
        if isinstance(other, Vector):#Данная проверка определяет, является ли объект other экземпляром класса Vector
            if len(self.values) == len(other.values):#Здесь проводится проверка на равенство длин векторов
                for i in range(len(self.values)):#Запускается цикл по всем элементам векторов
                    new_v.append(self.values[i] + other.values[i])#Результат сложения текущих элементов добавляется в список
                return Vector(*[i for i in new_v])#Создается и возвращается новый объект Vector, содержащий результат сложения
            else:
                print('сложение векторов разной длины недопустимо.')#Выводится сообщение о том, что сложение векторов разной длины недопустимо
        if isinstance(other, int):#проводится проверка, является ли other целым числом
            for i in range(len(self.values)):#Запускается цикл по всем элементам вектора
                new_v.append(self.values[i]+other)#Результат сложения текущего элемента с целым числом добавляется в список
            return Vector(*[i for i in new_v])#Создается и возвращается новый объект Vector, содержащий результат сложения
            if not isinstance(other, (Vector, int)):#
                print(f'Вектор нельзя сложить с {other}')# Выводится сообщение о том, что вектор нельзя сложить с данным объектом
    def __mul__(self, other):#Это объявление перегруженного метода умножения
        new_v=[]#Создается пустой список
        if isinstance(other, Vector):#Проверяется, является ли other объектом класса Vector
            if len(self.values) == len(other.values):#Проверяется, имеют ли вектора одинаковую длину
                for i in range(len(self.values)):#Цикл для умножения координат векторов
                    new_v.append(self.values[i] * other.values[i])#Умножение соответствующих координат векторов и добавление результата в список
                return Vector(*[i for i in new_v])#Возвращает новый вектор, составленный из значений в списке
            else:#если векторы имеют разную длину, выводится сообщение об ошибке
                print('сложение векторов разной длины недопустимо.')#Вывод сообщения 'сложение векторов разной длины недопустимо'
        if isinstance(other, int):#Проверяется, является ли other целым числом
            for i in range(len(self.values)):#Цикл для умножения координат вектора на целое число
                new_v.append(self.values[i]*other)#Умножение каждой координаты вектора на целое число и добавление результата в список
            return Vector(*[i for i in new_v])# Возвращает новый вектор, составленный из значений в списке
            if not isinstance(other, (Vector, int)):#Если other не является ни объектом класса Vector, ни целым числом, выводится сообщение об ошибке
                print(f'Вектор нельзя сложить с {other}')#
#Cоздаются объекты класса Vector с заданными координатами и производится операция сложения и умножения
v1=Vector(1,2,3)#создает объект класса v1
print(v1)
v2=Vector(4,7,1,12)
print(v2)
v3=Vector(7,11,3,18)
print(v3)
print(v2+v3)
print(v2*v3)